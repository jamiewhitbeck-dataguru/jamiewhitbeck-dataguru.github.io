CREATE PROCEDURE [dbo].[GetPagedData]
       @Tablename varchar ( 50 ),
       @TablePK varchar ( 50 ),
       @Page int,
       @MaxRows int,
       @OrderString varchar ( max ),
       @SearchString varchar ( max ),
       @Fields varchar ( max ),
       @Join varchar ( max ),
       @IncludeRowVersion bit

AS
BEGIN

SET NOCOUNT ON

/*
    Purpose: Retrieve paginated, filtered, and ordered data from specified table(s).
    Designed for: All mobile app page loads requiring a paginated list.
    Author: Jamie Whitbeck

    Design notes:
      - Initial CTE selects only primary keys, applies row numbering, and filters duplicates to optimize page calculations.
      - Data fields are joined later, only for the selected page rows, to improve performance.
      - NOLOCK is used intentionally for high-concurrency, read-only operations where dirty reads are acceptable.
      - All inputs are controlled by internal mobile app calls â€” zero risk of SQL injection.
      - Dynamic SQL enables flexibility, generating a new query plan per call:
          - The cost of recompilation is negligible in this context.
          - Recompilation often results in less I/O than executing with a stale plan, improving overall performance.
*/

DECLARE @SqlString nvarchar ( max )

-- Build initial string with only the primary key, row ordering, and a duplicate check from the primary table
SET @SqlString = '
WITH CTE_AllRecords AS (
  SELECT
      ' + @TableName + '.' + @TablePK + '
      ,RowNum = ROW_NUMBER () OVER (ORDER BY ' + @OrderString + ')
      ,DuplicateCheck = ROW_NUMBER () OVER (PARTITION BY ' + @TableName + '.' + @TablePK + ' ORDER BY ' + @TableName + '.' + @TablePK + ')
    FROM ' + @TableName + ' WITH(NoLock) '

-- If there are other tables being joined, add the JOIN statement to the string
-- This first join operates only on primary keys and does not returning data fields yet, optimizing performance
IF IsNull(@Join,'') != ''
  BEGIN
    SET @SqlString = @SqlString + ' ' + @Join
  END

-- If there are conditions in the WHERE clause, add it to the string
IF IsNull(@SearchString,'') != ''
  BEGIN
    SET @SqlString = @SqlString + ' WHERE ' + @SearchString
  END

-- Build the layered CTE structure
  -- Add count of pages for application to determine if to display next page button and final page number for jump to page functionality
  -- Add row numbers for start and end on the dataset being returned
  -- Add the data fields to be returned
SET @SqlString = @SqlString + '
  )
  ,CTE_RowNums AS (
    SELECT
      AR.' + @TablePK + '
      ,RowNum = ROW_NUMBER () OVER (ORDER BY RowNum)
    FROM CTE_AllRecords AR
    WHERE DuplicateCheck = 1
  )
  ,CTE_PageCount AS (
    SELECT
        RecordCount
        ,[PageCount] = CAST(RecordCount AS decimal(18,2))/CAST(' + CAST(@MaxRows as varchar(max)) + ' AS decimal(18,2))
        ,StartRow = ((' + CAST(@Page as varchar(max)) + ' - 1) * ' + CAST(@MaxRows as varchar(max)) + ') + 1
        ,EndRow = (((' + CAST(@Page as varchar(max)) + ' - 1) * ' + CAST(@MaxRows as varchar(max)) + ') + ' + CAST(@MaxRows as varchar(max)) + ')
      FROM (SELECT RecordCount = COUNT(' + @TablePK + ') FROM CTE_RowNums) AS A
  )

SELECT DISTINCT
    RN.RowNum
    ,PC.[PageCount]
    ,PC.RecordCount
    ,PC.StartRow
    ,PC.EndRow
    , ' + @Fields

-- Format the string to remove bad chars
IF RIGHT(RTrim(@SqlString),1) = ','
  BEGIN
    SET @SqlString = LEFT(RTrim(@SqlString),(LEN(RTrim(@SqlString))-1))
  END

-- Continue building string by adding the FROM, JOIN, WHERE, and ORDER BY clauses
SET @SqlString = @SqlString + '
    FROM CTE_PageCount PC
    INNER JOIN (SELECT * FROM CTE_RowNums) RN
      ON    RN.RowNum BETWEEN PC.StartRow AND PC.EndRow
    INNER JOIN ' + @TableName + ' WITH(NoLock)
      ON    RN.' + @TablePK + ' = ' + @TableName + '.' + @TablePK
-- Join the tables again, this time to return the actual data fields requested
IF IsNull(@Join,'') != ''
  BEGIN
    SET @SqlString = @SqlString + ' ' + @Join
  END

IF IsNull(@SearchString,'') != ''
  BEGIN
    SET @SqlString = @SqlString + ' WHERE ' + @SearchString
  END

SET @SqlString = @SqlString + ' ORDER BY RN.RowNum ASC'

SET NOCOUNT OFF

-- Execute the dynamic SQL
EXEC sp_executesql @SqlString

END
GO

/*
Sample execution call:
EXEC GetPagedData 'Asset', 'AssetPK', 1, 20, 'AssetName ASC', 'RepairCenter.RepairCenterPK = 1', 'Asset.AssetID, Asset.AssetName', 'INNER JOIN RepairCenter ON Asset.RepairCenterPK = RepairCenter.RepairCenterPK', 0
-- Page 3, return Asset ID and AssetName for assets assigned to the primary repair center, ordered by AssetName, 20 items/page


Dynamic SQL generated by sample execution:
WITH CTE_AllRecords AS (
  SELECT
      Asset.AssetPK
      ,RowNum = ROW_NUMBER () OVER (ORDER BY AssetName ASC)
      ,DuplicateCheck = ROW_NUMBER () OVER (PARTITION BY Asset.AssetPK ORDER BY Asset.AssetPK)
    FROM Asset WITH(NoLock)  INNER JOIN RepairCenter ON Asset.RepairCenterPK = RepairCenter.RepairCenterPK
    WHERE RepairCenter.RepairCenterPK = 1
  )
  ,CTE_RowNums AS (
    SELECT
      AR.AssetPK
      ,RowNum = ROW_NUMBER () OVER (ORDER BY RowNum)
    FROM CTE_AllRecords AR
    WHERE DuplicateCheck = 1
  )
  ,CTE_PageCount AS (
    SELECT
        RecordCount
        ,[PageCount] = CAST(RecordCount AS decimal(18,2))/CAST(20 AS decimal(18,2))
        ,StartRow = ((3 - 1) * 20) + 1
        ,EndRow = (((3 - 1) * 20) + 20)
      FROM (SELECT RecordCount = COUNT(AssetPK) FROM CTE_RowNums) AS A
  )

SELECT DISTINCT
    RN.RowNum
    ,PC.[PageCount]
    ,PC.RecordCount
    ,PC.StartRow
    ,PC.EndRow
    , Asset.AssetID, Asset.AssetName
    FROM CTE_PageCount PC
    INNER JOIN (SELECT * FROM CTE_RowNums) RN
      ON    RN.RowNum BETWEEN PC.StartRow AND PC.EndRow
    INNER JOIN Asset WITH(NoLock)
      ON    RN.AssetPK = Asset.AssetPK INNER JOIN RepairCenter ON Asset.RepairCenterPK = RepairCenter.RepairCenterPK
    WHERE RepairCenter.RepairCenterPK = 1
    ORDER BY RN.RowNum ASC

*/